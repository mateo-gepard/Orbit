rules_version = '2';

// ═══════════════════════════════════════════════════════════
// ORBIT — Firestore Security Rules
// ═══════════════════════════════════════════════════════════
//
// Diese Rules sorgen für:
// ✅ Jeder User sieht nur seine eigenen Items
// ✅ Keine Cross-User-Zugriffe möglich
// ✅ Nur authentifizierte User können schreiben
// ✅ Data Validation (userId muss gesetzt sein)
//
// Deploy via Firebase Console:
// Firestore Database → Rules → Paste & Publish
//
// ═══════════════════════════════════════════════════════════

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ─────────────────────────────────────────────────────────
    // Helper Functions
    // ─────────────────────────────────────────────────────────
    
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    function isValidItem() {
      let data = request.resource.data;
      return data.userId is string
          && data.title is string
          && data.type in ['task', 'project', 'habit', 'event', 'goal', 'note']
          && data.status in ['inbox', 'active', 'waiting', 'done', 'archived']
          && data.createdAt is int
          && data.updatedAt is int;
      // Note: files field is optional and not validated here
    }
    
    // ─────────────────────────────────────────────────────────
    // Items Collection
    // ─────────────────────────────────────────────────────────
    
    match /items/{itemId} {
      // READ: User kann nur eigene Items lesen
      allow read: if isSignedIn() 
                  && isOwner(resource.data.userId);
      
      // CREATE: User kann Items erstellen mit eigenem userId
      allow create: if isSignedIn()
                    && isOwner(request.resource.data.userId)
                    && isValidItem();
      
      // UPDATE: User kann nur eigene Items updaten
      // userId darf NICHT geändert werden (Sicherheit!)
      allow update: if isSignedIn()
                    && isOwner(resource.data.userId)
                    && isOwner(request.resource.data.userId)
                    && resource.data.userId == request.resource.data.userId;
      
      // DELETE: User kann nur eigene Items löschen
      allow delete: if isSignedIn()
                    && isOwner(resource.data.userId);
    }
    
    // ─────────────────────────────────────────────────────────
    // Analytics Collection (append-heavy, user-scoped)
    // ─────────────────────────────────────────────────────────
    
    match /analytics/{eventId} {
      // READ: User kann nur eigene Events lesen
      allow read: if isSignedIn()
                  && isOwner(resource.data.userId);
      
      // CREATE: User kann Events für sich selbst schreiben
      allow create: if isSignedIn()
                    && isOwner(request.resource.data.userId)
                    && request.resource.data.action is string
                    && request.resource.data.timestamp is int
                    && request.resource.data.date is string;
      
      // No update — analytics are immutable
      allow update: if false;

      // DELETE: User can delete their own analytics (account deletion)
      allow delete: if isSignedIn()
                    && isOwner(resource.data.userId);
    }
    
    // ─────────────────────────────────────────────────────────
    // User Settings Collection (tags, areas — per user)
    // Doc ID = userId, so only the owner can read/write
    // ─────────────────────────────────────────────────────────

    match /userSettings/{userId} {
      allow read: if isSignedIn() && isOwner(userId);
      allow create, update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    // ─────────────────────────────────────────────────────────
    // Tool Data Collection (per-user tool state)
    // Doc ID = userId_toolId, scoped by userId field
    // ─────────────────────────────────────────────────────────

    match /toolData/{docId} {
      // Read: allow if doc exists and user owns it,
      // OR if the docId starts with the user's uid (handles non-existent docs
      // which onSnapshot listens to — resource.data is null when doc missing)
      allow read: if isSignedIn()
                  && (resource == null
                      ? docId[0:request.auth.uid.size()] == request.auth.uid
                      : isOwner(resource.data.userId));
      allow create: if isSignedIn()
                    && isOwner(request.resource.data.userId);
      allow update: if isSignedIn()
                    && isOwner(resource.data.userId)
                    && isOwner(request.resource.data.userId);
      allow delete: if isSignedIn()
                    && isOwner(resource.data.userId);
    }

    // ─────────────────────────────────────────────────────────
    // Deny all other paths
    // ─────────────────────────────────────────────────────────
    
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

// ═══════════════════════════════════════════════════════════
// Testing in Firebase Console
// ═══════════════════════════════════════════════════════════
//
// Rules → "Rules Playground" Tab
//
// Test READ:
// Location: /items/test-item-123
// auth.uid: user-123
// Simulator data: { "userId": "user-123", "title": "Test" }
// → Should ALLOW
//
// Test READ (wrong user):
// Location: /items/test-item-123
// auth.uid: user-456
// Simulator data: { "userId": "user-123", "title": "Test" }
// → Should DENY
//
// ═══════════════════════════════════════════════════════════
